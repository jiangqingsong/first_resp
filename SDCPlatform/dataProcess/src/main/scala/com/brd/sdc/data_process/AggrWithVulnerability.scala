package com.brd.sdc.data_process

import com.brd.sdc.common.SparkEnvUtil._
import com.databricks.spark.xml._
import org.apache.spark.sql.DataFrame
/**
 * @author jiangqingsong
 * @description  dpi/scan数据和漏洞库关联
 * @date 2020-03-09 14:01
 */
object AggrWithVulnerability {
  import spark.implicits._


  def loadOriginData(tabName: String, day: String, minute: String): DataFrame ={
    val originDf = spark.sql(
      s"""
         |select * from $tabName where day=$day and minute=$minute
         |""".stripMargin)
    originDf
  }
  def broadcoastVulner(xmlPath: String): Map[String, Set[Vulnerability]] ={
    val xmlData = spark.read.option("rowTag", "vulnerability").xml(xmlPath)
    xmlData.registerTempTable("vulnerability_tmp")
    val formatedDF = spark.sql(
      s"""
         |select
         |description,
         |discovererName,
         |formalWay,
         |isEvent,
         |number,
         |openTime,
         |patchDescription,
         |patchName,
         |concat_ws('\001', products.product) as product,
         |serverity,
         |submitTime,
         |title
         |from vulnerability_tmp
         |""".stripMargin)


    val vulnerabilityMap = formatedDF.as[Vulnerability].rdd.map(v => {
      (v.product, v)
    }).groupByKey().map(g => {
      val products = g._1
      val vulnerabilityInfo = g._2.toSet
      (products, vulnerabilityInfo)
    }).collect().toMap

    vulnerabilityMap
  }
  /**
   * 主动探测关联漏洞库
   * @param day
   * @param minute
   * @param xmlPath
   * @param partitionNum
   */
  def aggrScanWithVulnerability(day: String, minute: String, xmlPath: String, partitionNum: String): Unit = {
    //加载原始表数据
    val tabName = "sdc_detail_pre.ppe_scanlog_pre"
    val scanlogDf = loadOriginData(tabName, day, minute)

    val vulnerMap = broadcoastVulner(xmlPath)
    val vulnerabilityMapBC = spark.sparkContext.broadcast(vulnerMap)
    val origin2vulnerability = scanlogDf.rdd.map(r => {
      val vulnerabilityMap = vulnerabilityMapBC.value

      val products = vulnerabilityMap.keySet

      def safeGet(col: String): String = {
        val vaule = r.getAs[String](col)
        if(vaule == null) "" else vaule.toString
      }
      val inputProduct = new StringBuilder
      val taskid = safeGet("taskid")
      val ip = safeGet("ip")
      val iptype = safeGet("iptype")
      val iphplace = safeGet("iphplace")
      val mac = safeGet("mac")
      val assettype = safeGet("type")
      val osver = safeGet("osver")
      val port = safeGet("port")
      val opstype = safeGet("opstype")
      val softver = safeGet("softver")
      val httpwarever = safeGet("httpwarever")
      val sfinfo = safeGet("sfinfo")
      val time = safeGet("time")
      inputProduct.append(osver).append(softver).append(httpwarever)
      val scanInputStr = inputProduct.toString()
      /**
       * 前面已经对漏洞库里面的products做了concat by ''\001'', 用原始数据中的devname\softname\softver\vendor\os
       * 来和products产品匹配：具体逻辑就是这段代码
       */
      val product2matchCnt = products.map( p =>{
        val matchCnt = p.split("\001").flatMap(_.split(" ")).filter(x => {
          scanInputStr.contains(x)
        }).size
        (p, matchCnt)
      })

      val topProductKey = product2matchCnt.toSeq.sortWith(_._2 > _._2).head._1
      val info = vulnerabilityMap.get(topProductKey).head.head
      PpeScanlog(taskid, ip, iptype, iphplace, mac, assettype, osver, port,
        opstype, softver, httpwarever, sfinfo,
        //原始文件存在换行符，一个坑fuck！
        info.number.replaceAll("\\r\\n", ""), info.title.replaceAll("\\r\\n", ""),
        info.serverity.replaceAll("\\r\\n", ""), info.product.replaceAll("\\r\\n", ""),
        info.isevent.replaceAll("\\r\\n", ""), info.submittime.replaceAll("\\r\\n", ""),
        info.opentime.replaceAll("\\r\\n", ""),info.discoverername.replaceAll("\\r\\n", ""),
        info.formalway.replaceAll("\\r\\n", ""), info.description.replaceAll("\\r\\n", ""),
        info.patchname.replaceAll("\\r\\n", ""), info.patchdescription.replaceAll("\\r\\n", ""),
        time
      )
    })

    origin2vulnerability.toDF().repartition(partitionNum.toInt).registerTempTable("p_tmp")
    spark.sql(s"INSERT OVERWRITE TABLE sdc_detail.ppe_scanlog PARTITION(day=$day,minute=$minute) " +
      s"SELECT * FROM p_tmp")
  }
  /**
   * dpi数据和漏洞库关联
   * @param day
   * @param minute
   * @param xmlPath
   */
  def aggrDpiWithVulnerability(day: String, minute: String, xmlPath: String, partitionNum: String): Unit = {
    //加载原始表数据
    val tabName = "sdc_detail_pre.ppe_dpilog_pre"
    //xmlPath (test): "/jqs/test/data/xml/CNDV.xml"
    val dpilogDf = loadOriginData(tabName, day, minute)
    val vulnerabilityMap = broadcoastVulner(xmlPath)
    val vulnerabilityMapBC = spark.sparkContext.broadcast(vulnerabilityMap)
    val origin2vulnerability = dpilogDf.as[PpeDpilogPre].rdd.map(r => {
      val vulnerabilityMap = vulnerabilityMapBC.value

      val products = vulnerabilityMap.keySet

      val inputProduct = new StringBuilder
      inputProduct.append(r.devname).append(r.softname).append(r.softver).append(r.vendor).append(r.os)
      val inputStr = inputProduct.toString()
      /**
       * 前面已经对漏洞库里面的products做了concat by ''\001'', 用原始数据中的devname\softname\softver\vendor\os
       * 来和products产品匹配：具体逻辑就是这段代码
       */
      val product2matchCnt = products.map( p =>{
        val matchCnt = p.split("\001").flatMap(_.split(" ")).filter(x => {
          inputStr.contains(x)
        }).size
        (p, matchCnt)
      })

      val topProductKey = product2matchCnt.toSeq.sortWith(_._2 > _._2).head._1
      val info = vulnerabilityMap.get(topProductKey).head.head
      PpeDpilog(r.taskid, r.srciptype, r.dstiptype, r.trproto, r.protocol, r.srcport, r.dstport, r.starttime, r.endtime,
        r.utraffic, r.dtraffic, r.upacktes, r.dpackets, r.srcip, r.dstip, r.devname, r.softname, r.softver,
        r.vendor, r.os, r.osver,
        //原始文件存在换行符，需要处理掉！
        info.number.replaceAll("\\r\\n", ""), info.title.replaceAll("\\r\\n", ""),
        info.serverity.replaceAll("\\r\\n", ""), info.product.replaceAll("\\r\\n", ""),
        info.isevent.replaceAll("\\r\\n", ""), info.submittime.replaceAll("\\r\\n", ""),
        info.opentime.replaceAll("\\r\\n", ""),info.discoverername.replaceAll("\\r\\n", ""),
        info.formalway.replaceAll("\\r\\n", ""), info.description.replaceAll("\\r\\n", ""),
        info.patchname.replaceAll("\\r\\n", ""), info.patchdescription.replaceAll("\\r\\n", "")
      )
    })

    origin2vulnerability.toDF().repartition(partitionNum.toInt).registerTempTable("o_tmp")
    spark.sql(s"INSERT OVERWRITE TABLE sdc_detail.ppe_dpilog PARTITION(day=$day,minute=$minute) " +
      s"SELECT * FROM o_tmp")
  }
}




case class PpeScanlogPre(
                          taskid :String,
                          ip :String,
                          iptype :String,
                          iphplace :String,
                          mac :String,
                          type1 :String,//关键字
                          osver :String,
                          port :String,
                          opstype :String,
                          softver :String,
                          httpwarever :String,
                          sfinfo :String,
                          time :String
                        )

case class PpeScanlog(
                       taskid :String,
                       ip :String,
                       iptype :String,
                       iphplace :String,
                       mac :String,
                       assettype :String,
                       osver :String,
                       port :String,
                       opstype :String,
                       softver :String,
                       httpwarever :String,
                       sfinfo :String,
                       number :String,
                       title :String,
                       serverity :String,
                       products :String,
                       isevent :String,
                       submittime :String,
                       opentime :String,
                       discoverername :String,
                       formalway :String,
                       description :String,
                       patchname :String,
                       patchdescription :String,
                       time :String
                     )

case class PpeDpilogPre(
                         taskid :String,
                         srciptype :String,
                         dstiptype :String,
                         trproto :String,
                         assettype :String,
                         protocol :String,
                         srcport :String,
                         dstport :String,
                         starttime :String,
                         endtime :String,
                         utraffic :String,
                         dtraffic :String,
                         upacktes :String,
                         dpackets :String,
                         srcip :String,
                         dstip :String,
                         devtype :String,
                         devname :String,
                         softname :String,
                         softver :String,
                         vendor :String,
                         os :String,
                         osver :String,
                         nettype :String
                       )
case class PpeDpilog(
                      taskid :String,
                      srciptype :String,
                      dstiptype :String,
                      trproto :String,
                      protocol :String,
                      srcport :String,
                      dstport :String,
                      starttime :String,
                      endtime :String,
                      utraffic :String,
                      dtraffic :String,
                      upacktes :String,
                      dpackets :String,
                      srcip :String,
                      dstip :String,
                      devname :String,
                      softname :String,
                      softver :String,
                      vendor :String,
                      os :String,
                      osver :String,
                      number :String,
                      title :String,
                      serverity :String,
                      products :String,
                      isevent :String,
                      submittime :String,
                      opentime :String,
                      discoverername :String,
                      formalway :String,
                      description :String,
                      patchname :String,
                      patchdescription :String
                    )
case class Vulnerability(
                          //bidNumber: String,
                          //bidUrl: String,
                          //cveNumber: String,
                          //cveUrl: String,
                          description: String, //
                          discoverername: String, //
                          formalway: String, //
                          isevent: String, //
                          number: String, //
                          opentime: String, //
                          patchdescription: String, //
                          patchname: String, //
                          product: String, //
                          //referenceLink: String,
                          serverity: String, //
                          submittime: String, //
                          title: String //
                        )
